class Ekf2;

 

namespace ekf2

{

Ekf2 *instance = nullptr;

}

 

 

class Ekf2 : public control::SuperBlock

{

public:

        Ekf2();

        ~Ekf2();

        int            start();

 

        void    set_replay_mode(bool replay) {_replay_mode = replay;};

 

        static void    task_main_trampoline(int argc, char *argv[]);

 

        void           task_main();

 

        void print_status();

 

        void LLA2NED(float *home_pos_LLA, float *cur_pos_LLA, float *result);

        void exit() { _task_should_exit = true; }

 

private:

        static constexpr float _dt_max = 0.02;

        bool    _task_should_exit = false;

        int     _control_task = -1;           // task handle for task

        bool    _replay_mode;                 // should we use replay data from a log

        int     _publish_replay_mode;        // defines if we should publish replay messages

 

        Vector3f _delVel_sum;

 

        math::Matrix<3, 3>    _board_rotation;

 

        int     _sensors_sub = -1;

        int     _gps_sub = -1;

        //int  _airspeed_sub = -1;

        int     _params_sub = -1;

        int     _actuator_armed_sub = -1;

        int     _vehicle_land_detected_sub = -1;

        int _status_sub = -1;

        int _serial_com_sub = -1;

        int _home_position_sub = -1; // Added for Home position

 

        bool    _prev_landed = true;  // landed status from the previous frame

 

        float _acc_hor_filt = 0.0f; // low-pass filtered horizontal acceleration

 

        orb_advert_t _att_pub;

        orb_advert_t _airspeed_pub;

        orb_advert_t _lpos_pub;

        orb_advert_t _control_state_pub;

        orb_advert_t _vehicle_global_position_pub;

        orb_advert_t _wind_pub;

        orb_advert_t _estimator_status_pub;

        orb_advert_t _replay_pub;

 

        Ekf _ekf;

 

        parameters *_params;  // pointer to ekf parameter struct (located in _ekf class instance)

 

        control::BlockParamFloat _mag_delay_ms;

        control::BlockParamFloat _baro_delay_ms;

        control::BlockParamFloat _gps_delay_ms;

        control::BlockParamFloat _rng_delay_ms;

        control::BlockParamFloat _airspeed_delay_ms;

 

        control::BlockParamFloat _gyro_noise;

        control::BlockParamFloat _accel_noise;

 

        // process noise

        control::BlockParamFloat _gyro_bias_p_noise;

        control::BlockParamFloat _accel_bias_p_noise;

        control::BlockParamFloat _mage_p_noise;

        control::BlockParamFloat _magb_p_noise;

        control::BlockParamFloat _wind_vel_p_noise;

        control::BlockParamFloat _terrain_p_noise;  // terrain offset state random walk (m/s)

        control::BlockParamFloat _terrain_gradient; // magnitude of terrain gradient (m/m)

 

        control::BlockParamFloat _gps_vel_noise;

        control::BlockParamFloat _gps_pos_noise;

        control::BlockParamFloat _pos_noaid_noise;

        control::BlockParamFloat _baro_noise;

        control::BlockParamFloat _baro_innov_gate;     // innovation gate for barometric height innovation test (std dev)

        control::BlockParamFloat _posNE_innov_gate;    // innovation gate for GPS horizontal position innovation test (std dev)

        control::BlockParamFloat _vel_innov_gate;      // innovation gate for GPS velocity innovation test (std dev)

        control::BlockParamFloat _tas_innov_gate;      // innovation gate for tas innovation test (std dev)

 

        control::BlockParamFloat _mag_heading_noise;       // measurement noise used for simple heading fusion

        control::BlockParamFloat _mag_noise;           // measurement noise used for 3-axis magnetoemter fusion (Gauss)

        control::BlockParamFloat _eas_noise;                // measurement noise used for airspeed fusion (std m/s)

        control::BlockParamFloat _mag_declination_deg;     // magnetic declination in degrees

        control::BlockParamFloat _heading_innov_gate;      // innovation gate for heading innovation test

        control::BlockParamFloat _mag_innov_gate;   // innovation gate for magnetometer innovation test

        control::BlockParamInt

        _mag_decl_source;       // bitmasked integer used to control the handling of magnetic declination

        control::BlockParamInt _mag_fuse_type;         // integer ued to control the type of magnetometer fusion used

 

        control::BlockParamInt _gps_check_mask;        // bitmasked integer used to activate the different GPS quality checks

        control::BlockParamFloat _requiredEph;         // maximum acceptable horiz position error (m)

        control::BlockParamFloat _requiredEpv;         // maximum acceptable vert position error (m)

        control::BlockParamFloat _requiredSacc;        // maximum acceptable speed error (m/s)

        control::BlockParamInt _requiredNsats;         // minimum acceptable satellite count

        control::BlockParamFloat _requiredGDoP;        // maximum acceptable geometric dilution of precision

        control::BlockParamFloat _requiredHdrift;      // maximum acceptable horizontal drift speed (m/s)

        control::BlockParamFloat _requiredVdrift;      // maximum acceptable vertical drift speed (m/s)

        control::BlockParamInt _param_record_replay_msg; // indicates if we want to record ekf2 replay messages

 

        // measurement source control

        control::BlockParamInt

        _fusion_mode;         // bitmasked integer that selects which of the GPS and optical flow aiding sources will be used

        control::BlockParamInt _vdist_sensor_type;  // selects the primary source for height data

 

        // range finder fusion

        control::BlockParamFloat _range_noise;              // observation noise for range finder measurements (m)

        control::BlockParamFloat _range_innov_gate; // range finder fusion innovation consistency gate size (STD)

        control::BlockParamFloat _rng_gnd_clearance;       // minimum valid value for range when on ground (m)

 

        // control of airspeed and sideslip fusion

        control::BlockParamFloat

        _arspFusionThreshold;         // a value of zero will disabled airspeed fusion. Any another positive value will determine

        // the minimum airspeed which will still be fused

 

        // output predictor filter time constants

        control::BlockParamFloat _tau_vel;   // time constant used by the output velocity complementary filter (s)

        control::BlockParamFloat _tau_pos;   // time constant used by the output position complementary filter (s)

 

        // IMU switch on bias paameters

        control::BlockParamFloat _gyr_bias_init;    // 1-sigma gyro bias uncertainty at switch-on (rad/sec)

        control::BlockParamFloat _acc_bias_init;    // 1-sigma accelerometer bias uncertainty at switch-on (m/s**2)

        control::BlockParamFloat _ang_err_init;             // 1-sigma uncertainty in tilt angle after gravity vector alignment (rad)

 

        // airspeed mode parameter

        control::BlockParamInt _airspeed_mode;

 

        int update_subscriptions();

 

};

 

Ekf2::Ekf2():

        SuperBlock(NULL, "EKF"),

        _replay_mode(false),

        _publish_replay_mode(0),

 

        _att_pub(nullptr),

        _airspeed_pub(nullptr),

        _lpos_pub(nullptr),

        _control_state_pub(nullptr),

        _vehicle_global_position_pub(nullptr),

        _wind_pub(nullptr),

        _estimator_status_pub(nullptr),

        _replay_pub(nullptr),

        _ekf(),

        _params(_ekf.getParamHandle()),

        _mag_delay_ms(this, "EKF2_MAG_DELAY", false, &_params->mag_delay_ms),

        _baro_delay_ms(this, "EKF2_BARO_DELAY", false, &_params->baro_delay_ms),

        _gps_delay_ms(this, "EKF2_GPS_DELAY", false, &_params->gps_delay_ms),

        _rng_delay_ms(this, "EKF2_RNG_DELAY", false, &_params->range_delay_ms),

        _airspeed_delay_ms(this, "EKF2_ASP_DELAY", false, &_params->airspeed_delay_ms),

        _gyro_noise(this, "EKF2_GYR_NOISE", false, &_params->gyro_noise),

        _accel_noise(this, "EKF2_ACC_NOISE", false, &_params->accel_noise),

        _gyro_bias_p_noise(this, "EKF2_GYR_B_NOISE", false, &_params->gyro_bias_p_noise),

        _accel_bias_p_noise(this, "EKF2_ACC_B_NOISE", false, &_params->accel_bias_p_noise),

        _mage_p_noise(this, "EKF2_MAG_E_NOISE", false, &_params->mage_p_noise),

        _magb_p_noise(this, "EKF2_MAG_B_NOISE", false, &_params->magb_p_noise),

        _wind_vel_p_noise(this, "EKF2_WIND_NOISE", false, &_params->wind_vel_p_noise),

        _terrain_p_noise(this, "EKF2_TERR_NOISE", false, &_params->terrain_p_noise),

        _terrain_gradient(this, "EKF2_TERR_GRAD", false, &_params->terrain_gradient),

        _gps_vel_noise(this, "EKF2_GPS_V_NOISE", false, &_params->gps_vel_noise),

        _gps_pos_noise(this, "EKF2_GPS_P_NOISE", false, &_params->gps_pos_noise),

        _pos_noaid_noise(this, "EKF2_NOAID_NOISE", false, &_params->pos_noaid_noise),

        _baro_noise(this, "EKF2_BARO_NOISE", false, &_params->baro_noise),

        _baro_innov_gate(this, "EKF2_BARO_GATE", false, &_params->baro_innov_gate),

        _posNE_innov_gate(this, "EKF2_GPS_P_GATE", false, &_params->posNE_innov_gate),

        _vel_innov_gate(this, "EKF2_GPS_V_GATE", false, &_params->vel_innov_gate),

        _tas_innov_gate(this, "EKF2_TAS_GATE", false, &_params->tas_innov_gate),

        _mag_heading_noise(this, "EKF2_HEAD_NOISE", false, &_params->mag_heading_noise),

        _mag_noise(this, "EKF2_MAG_NOISE", false, &_params->mag_noise),

        _eas_noise(this, "EKF2_EAS_NOISE", false, &_params->eas_noise),

        _mag_declination_deg(this, "EKF2_MAG_DECL", false, &_params->mag_declination_deg),

        _heading_innov_gate(this, "EKF2_HDG_GATE", false, &_params->heading_innov_gate),

        _mag_innov_gate(this, "EKF2_MAG_GATE", false, &_params->mag_innov_gate),

        _mag_decl_source(this, "EKF2_DECL_TYPE", false, &_params->mag_declination_source),

        _mag_fuse_type(this, "EKF2_MAG_TYPE", false, &_params->mag_fusion_type),

        _gps_check_mask(this, "EKF2_GPS_CHECK", false, &_params->gps_check_mask),

        _requiredEph(this, "EKF2_REQ_EPH", false, &_params->req_hacc),

        _requiredEpv(this, "EKF2_REQ_EPV", false, &_params->req_vacc),

        _requiredSacc(this, "EKF2_REQ_SACC", false, &_params->req_sacc),

        _requiredNsats(this, "EKF2_REQ_NSATS", false, &_params->req_nsats),

        _requiredGDoP(this, "EKF2_REQ_GDOP", false, &_params->req_gdop),

        _requiredHdrift(this, "EKF2_REQ_HDRIFT", false, &_params->req_hdrift),

        _requiredVdrift(this, "EKF2_REQ_VDRIFT", false, &_params->req_vdrift),

        _param_record_replay_msg(this, "EKF2_REC_RPL", false, &_publish_replay_mode),

        _fusion_mode(this, "EKF2_AID_MASK", false, &_params->fusion_mode),

        _vdist_sensor_type(this, "EKF2_HGT_MODE", false, &_params->vdist_sensor_type),

        _range_noise(this, "EKF2_RNG_NOISE", false, &_params->range_noise),

        _range_innov_gate(this, "EKF2_RNG_GATE", false, &_params->range_innov_gate),

        _rng_gnd_clearance(this, "EKF2_MIN_RNG", false, &_params->rng_gnd_clearance),

        _arspFusionThreshold(this, "EKF2_ARSP_THR", false),

        _tau_vel(this, "EKF2_TAU_VEL", false, &_params->vel_Tau),

        _tau_pos(this, "EKF2_TAU_POS", false, &_params->pos_Tau),

        _gyr_bias_init(this, "EKF2_GBIAS_INIT", false, &_params->switch_on_gyro_bias),

        _acc_bias_init(this, "EKF2_ABIAS_INIT", false, &_params->switch_on_accel_bias),

        _ang_err_init(this, "EKF2_ANGERR_INIT", false, &_params->initial_tilt_err),

        _airspeed_mode(this, "FW_ARSP_MODE", false)

{

               _delVel_sum = {};

 

}

 

Ekf2::~Ekf2()

{

}

 

void Ekf2::print_status()

{

        warnx("local position OK %s", (_ekf.local_position_is_valid()) ? "[YES]" : "[NO]");

        warnx("global position OK %s", (_ekf.global_position_is_valid()) ? "[YES]" : "[NO]");

}

void Ekf2::LLA2NED(float *home_pos_LLA, float *cur_pos_LLA, float *result)

{

        float exp = 0.08181919f;

        float Ne, Ner;

        float xe, ye, ze;

        float xer, yer, zer;

 

        //double _position_NED[3] = {0.0};

 

        // LLA[0] = Latitude, LLA[1] = Longitude, LLA[2] = height

        Ne = 6378137.0f / sqrtf(1.0f-exp*exp*sinf(cur_pos_LLA[0])*sinf(cur_pos_LLA[0]));

        Ner = 6378137.0f / sqrtf(1.0f-exp*exp*sinf(home_pos_LLA[0])*sinf(home_pos_LLA[0]));

 

        xe = (Ne + cur_pos_LLA[2])*cosf(cur_pos_LLA[0])*cosf(cur_pos_LLA[1]);

        ye = (Ne + cur_pos_LLA[2])*cosf(cur_pos_LLA[0])*sinf(cur_pos_LLA[1]);

        ze = (Ne*(1.0f-exp*exp) + cur_pos_LLA[2])*sinf(cur_pos_LLA[0]);

 

        xer = (Ner + home_pos_LLA[2])*cosf(home_pos_LLA[0])*cosf(home_pos_LLA[1]);

        yer = (Ner + home_pos_LLA[2])*cosf(home_pos_LLA[0])*sinf(home_pos_LLA[1]);

        zer = (Ner*(1.0f-exp*exp) + home_pos_LLA[2])*sinf(home_pos_LLA[0]);

 

        result[0] = -sinf(home_pos_LLA[0])*cosf(home_pos_LLA[1])*(xe-xer) -sinf(home_pos_LLA[0])*sinf(home_pos_LLA[1])*(ye-yer) + cosf(home_pos_LLA[0])*(ze-zer);

        result[1] = -sinf(home_pos_LLA[1])*(xe-xer) + cosf(home_pos_LLA[1])*(ye-yer);

        result[2] = -cosf(home_pos_LLA[0])*cosf(home_pos_LLA[1])*(xe-xer) - cosf(home_pos_LLA[0])*sinf(home_pos_LLA[1])*(ye-yer) - sinf(home_pos_LLA[0])*(ze-zer);

 

//     return _position_NED;

 

}

void Ekf2::task_main()

{

        // subscribe to relevant topics

        _sensors_sub = orb_subscribe(ORB_ID(sensor_combined));

        _gps_sub = orb_subscribe(ORB_ID(vehicle_gps_position));

        _params_sub = orb_subscribe(ORB_ID(parameter_update));

        _vehicle_land_detected_sub = orb_subscribe(ORB_ID(vehicle_land_detected));

        _status_sub = orb_subscribe(ORB_ID(vehicle_status));

        _serial_com_sub = orb_subscribe(ORB_ID(serial_com));

        _home_position_sub = orb_subscribe(ORB_ID(home_position)); // Added for Home position

 

        px4_pollfd_struct_t fds[2] = {};

        fds[0].fd = _sensors_sub;

        fds[0].events = POLLIN;

        fds[1].fd = _params_sub;

        fds[1].events = POLLIN;

 

        // initialise parameter cache

        updateParams();

 

        while (!_task_should_exit)

        {

 
               orb_check(_serial_com_sub, &serial_com_updated);

               if (serial_com_updated)      orb_copy(ORB_ID(serial_com), _serial_com_sub, &_serial_com);

 

               orb_check(_home_position_sub, &home_position_upodated);

               if (home_position_upodated) orb_copy(ORB_ID(home_position), _home_position_sub, &_home_position);

 


               orb_check(_gps_sub, &gps_updated);
               if (gps_updated) {

                       orb_copy(ORB_ID(vehicle_gps_position), _gps_sub, &gps);
               }
 

               /*

               if (serial_com_updated) {

                       struct gps_message gps_msg = {};

                       gps_msg.time_usec     = gps.timestamp;//_serial_com.timestamp;

                       gps_msg.lat           = _serial_com.latitude*1e7f;

                       gps_msg.lon           = _serial_com.longitude*1e7f;

                       gps_msg.alt           = _serial_com.altitude*1000.0f;// * 0.01f;

 

                       gps_msg.fix_type =  3;//gps.fix_type;

                       gps_msg.eph =         2.0f;//gps.eph;

                       gps_msg.epv =         4.0f;//gps.epv;

                       gps_msg.sacc =        1.0f;//gps.s_variance_m_s;

                       gps_msg.vel_m_s = sqrtf(_serial_com.v_n*_serial_com.v_n+_serial_com.v_e*_serial_com.v_e+_serial_com.v_d*_serial_com.v_d);//0.0f;//gps.vel_m_s;

                       gps_msg.vel_ned[0] = _serial_com.v_n;///gps.vel_n_m_s;

                       gps_msg.vel_ned[1] = _serial_com.v_e;//gps.vel_e_m_s;

                       gps_msg.vel_ned[2] = _serial_com.v_d;//gps.vel_d_m_s;

                       gps_msg.vel_ned_valid = true;///gps.vel_ned_valid;

                       gps_msg.nsats = 9.0f;//gps.satellites_used;

                       //TODO add gdop to gps topic

                       gps_msg.gdop = 0.0f;

 

                       _ekf.setGpsData(gps.timestamp, &gps_msg);

               }

               */

 

               orb_check(_vehicle_land_detected_sub, &vehicle_land_detected_updated);

 

               if (vehicle_land_detected_updated) {

                       orb_copy(ORB_ID(vehicle_land_detected), _vehicle_land_detected_sub, &vehicle_land_detected);

                       //_ekf.set_in_air_status(!vehicle_land_detected.landed);

               }

 

 

               // run the EKF update and output

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

               //if (_ekf.update() && serial_com_updated)

               if (serial_com_updated)

               {

                       // generate attitude publication

                       struct vehicle_attitude_s att = {};

                       matrix::Quaternion<float> q(1.0f, 0.0f, 0.0f, 0.0f);

                       att.timestamp = hrt_absolute_time();

 

                       // generate control state data

                       control_state_s ctrl_state = {};

                       ctrl_state.timestamp = hrt_absolute_time();

 

                       // Input data: [deg/sec], with SF 20

                       ctrl_state.roll_rate = (float)_serial_com.roll_rate*0.000872664626f;             // Converted to rad/sec (with SF=0.05)

                       ctrl_state.pitch_rate = (float)_serial_com.pitch_rate*0.000872664626f;           // Converted to rad/sec (with SF=0.05)

                       ctrl_state.yaw_rate = (float)_serial_com.yaw_rate*0.000872664626f;                      // Converted to rad/sec (with SF=0.05)

 

                       // Input data: [deg], with SF 100

                       att.roll = (float)_serial_com.roll_angle*0.00017532952f;  // Converted to rad (with SF=0.01)

                       att.pitch = (float)_serial_com.pitch_angle*0.00017532952f; // Converted to rad (with SF=0.01)

                       att.yaw = (float)_serial_com.yaw_angle*0.00017532952f;            // Converted to rad (with SF=0.01)

 

                       att.rollspeed = ctrl_state.roll_rate;

                       att.pitchspeed        = ctrl_state.pitch_rate;

                       att.yawspeed   = ctrl_state.yaw_rate;

 

                       // Publish the attitude data

                       if (_att_pub == nullptr)     _att_pub = orb_advertise(ORB_ID(vehicle_attitude), &att);

                       else   orb_publish(ORB_ID(vehicle_attitude), _att_pub, &att);

 

                       float euler_phi               = att.roll;

                       float euler_theta     = att.pitch;

                       float euler_psi               = att.yaw;

 

                       float cosPhi_2 = float(cos(euler_phi*0.5f));

                       float cosTheta_2 = float(cos(euler_theta*0.5f));

                       float cosPsi_2 = float(cos(euler_psi*0.5f));

                       float sinPhi_2 = float(sin(euler_phi*0.5f));

                       float sinTheta_2 = float(sin(euler_theta*0.5f));

                       float sinPsi_2 = float(sin(euler_psi*0.5f));

                       q(0) = cosPhi_2 * cosTheta_2 * cosPsi_2 + sinPhi_2 * sinTheta_2 * sinPsi_2;

                       q(1) = sinPhi_2 * cosTheta_2 * cosPsi_2 - cosPhi_2 * sinTheta_2 * sinPsi_2;

                       q(2) = cosPhi_2 * sinTheta_2 * cosPsi_2 + sinPhi_2 * cosTheta_2 * sinPsi_2;

                       q(3) = cosPhi_2 * cosTheta_2 * sinPsi_2 - sinPhi_2 * sinTheta_2 * cosPsi_2;

 

                       ctrl_state.q[0] = q(0);

                       ctrl_state.q[1] = q(1);

                       ctrl_state.q[2] = q(2);

                       ctrl_state.q[3] = q(3);

 

                       ctrl_state.x_acc = 0.0f;

                       ctrl_state.y_acc = 0.0f;

                       ctrl_state.z_acc = 9.8f;

 

 

                       // generate vehicle local position data

                       struct vehicle_local_position_s lpos = {};

                       //float pos[3] = {};

                       float vel[3] = {};

                       float home_pos_LLA[3] = {};

                       float pos_LLA[3] = {};

                       float pos_NED[3] = {};

 

                       home_pos_LLA[0] = math::radians(_home_position.lat);

                       home_pos_LLA[1] = math::radians(_home_position.lon);

                       home_pos_LLA[2] = (float)_home_position.alt;

 

                       pos_LLA[0] = math::radians(_serial_com.latitude);

                       pos_LLA[1] = math::radians(_serial_com.longitude);

                       pos_LLA[2] = _serial_com.altitude;

                       LLA2NED(home_pos_LLA, pos_LLA, pos_NED);

 

                       vel[0] = (float)_serial_com.v_n*0.01f;             // Converted to m/sec (SF = 0.01)

                       vel[1] = (float)_serial_com.v_e*0.01f;             // Converted to m/sec (SF = 0.01)

                       vel[2] = (float)_serial_com.v_d*0.01f;             // Converted to m/sec (SF = 0.01)

 

                       // Velocity in body frame

                       //float velocity[3];

                       //_ekf.get_velocity(velocity);

                       Vector3f v_n(vel);

                       matrix::Dcm<float> R_to_body(q.inversed());

                       Vector3f v_b = R_to_body * v_n;

                       ctrl_state.x_vel = v_b(0);

                       ctrl_state.y_vel = v_b(1);

                       ctrl_state.z_vel = v_b(2);

 

                       // Local Position NED

                       ctrl_state.x_pos = pos_LLA[0];

                       ctrl_state.y_pos = pos_LLA[1];

                       ctrl_state.z_pos = pos_LLA[2];

 

                       ctrl_state.x_acc = (float)_serial_com.x_n*0.01f;

                       ctrl_state.x_acc = (float)_serial_com.y_e*0.01f;

                       ctrl_state.x_acc = (float)_serial_com.z_d*0.01f;

 

                       ctrl_state.airspeed_valid = false;//true;

                       //ctrl_state.airspeed                = _serial_arsp;

 

                       if (_control_state_pub == nullptr)   _control_state_pub = orb_advertise(ORB_ID(control_state), &ctrl_state);

                       else   orb_publish(ORB_ID(control_state), _control_state_pub, &ctrl_state);

 

                       // Position of body origin in local NED frame

                       // Generate local position data

                       lpos.timestamp = hrt_absolute_time();

                       lpos.x = pos_NED[0];

                       lpos.y = pos_NED[1];

                       lpos.z = pos_NED[2];

 

                       lpos.vx = vel[0];

                       lpos.vy = vel[1];

                       lpos.vz = vel[2];

 

                       // TODO: better status reporting

                       lpos.xy_valid = true;

                       lpos.z_valid = true;

                       lpos.v_xy_valid = true;

                       lpos.v_z_valid = true;

 

                       // Position of local NED origin in GPS / WGS84 frame

                       // true if position (x, y) is valid and has valid global reference (ref_lat, ref_lon)

                       lpos.xy_global =true;// _ekf.global_position_is_valid();

                       lpos.z_global = true;                                // true if z is valid and has valid global reference (ref_alt)

                       lpos.ref_lat = math::degrees((double)home_pos_LLA[0]);//_serial_com.latitude;//ekf_origin.lat_rad * 180.0 / M_PI; // Reference point latitude in degrees

                       lpos.ref_lon = math::degrees((double)home_pos_LLA[1]);//_serial_com.longitude;//ekf_origin.lon_rad * 180.0 / M_PI; // Reference point longitude in degrees

 

                       // The rotation of the tangent plane vs. geographical north

                       lpos.yaw = att.yaw;

 

                       //float terrain_vpos;

                       lpos.dist_bottom_valid = false;//ekf.get_terrain_vert_pos(&terrain_vpos);

                       //lpos.dist_bottom = terrain_vpos - pos[2]; // Distance to bottom surface (ground) in meters

                       lpos.dist_bottom_rate = -vel[2]; // Distance to bottom surface (ground) change rate

                       lpos.surface_bottom_timestamp = hrt_absolute_time(); // Time when new bottom surface found

 

                       // TODO: uORB definition does not define what these variables are. We have assumed them to be horizontal and vertical 1-std dev accuracy in metres

                       Vector3f pos_var, vel_var;

                       lpos.eph = 0.1f;

                       lpos.epv = 0.1f;

 

                       // publish vehicle local position data

                       if (_lpos_pub == nullptr) {

                              _lpos_pub = orb_advertise(ORB_ID(vehicle_local_position), &lpos);

 

                       } else {

                              orb_publish(ORB_ID(vehicle_local_position), _lpos_pub, &lpos);

                       }

 

                       // generate and publish global position data

                       struct vehicle_global_position_s global_pos = {};

 

                       global_pos.timestamp = hrt_absolute_time(); // Time of this estimate, in microseconds since system start

                       global_pos.time_utc_usec = gps.time_utc_usec; // GPS UTC timestamp in microseconds

 

                       global_pos.lat = (double)_serial_com.latitude; // Latitude in degrees

                       global_pos.lon = (double)_serial_com.longitude; // Longitude in degrees

                       global_pos.alt = _serial_com.altitude;//_serial_com.altitude; // Altitude AMSL in meters

 

                       global_pos.vel_n = vel[0]; // Ground north velocity, m/s

                       global_pos.vel_e = vel[1]; // Ground east velocity, m/s

                       global_pos.vel_d = vel[2]; // Ground downside velocity, m/s

                       global_pos.yaw = att.yaw; // Yaw in radians -PI..+PI.

                       global_pos.eph = 1.0f;

                       global_pos.epv = 1.0f;

 

                       global_pos.dead_reckoning = false;

                       global_pos.pressure_alt = global_pos.alt;

 

                       if (_vehicle_global_position_pub == nullptr)_vehicle_global_position_pub = orb_advertise(ORB_ID(vehicle_global_position), &global_pos);

                       else   orb_publish(ORB_ID(vehicle_global_position), _vehicle_global_position_pub, &global_pos);

 

               }

/*

               else if (_replay_mode)

               {

                       struct vehicle_attitude_s att = {};

                       att.timestamp = 0;

                       if (_att_pub == nullptr)_att_pub = orb_advertise(ORB_ID(vehicle_attitude), &att);

                       else   orb_publish(ORB_ID(vehicle_attitude), _att_pub, &att);

               }

*/

 

/*

 

               // publish estimator status

               struct estimator_status_s status = {};

               status.timestamp = hrt_absolute_time();

               _ekf.get_state_delayed(status.states);

               _ekf.get_covariances(status.covariances);

               _ekf.get_gps_check_status(&status.gps_check_fail_flags);

               _ekf.get_control_mode(&status.control_mode_flags);

               _ekf.get_filter_fault_status(&status.filter_fault_flags);

 

               if (_estimator_status_pub == nullptr) {

                       _estimator_status_pub = orb_advertise(ORB_ID(estimator_status), &status);

 

               } else {

                       orb_publish(ORB_ID(estimator_status), _estimator_status_pub, &status);

               }

 

               // Publish wind estimate

               struct wind_estimate_s wind_estimate = {};

               wind_estimate.timestamp = hrt_absolute_time();

               wind_estimate.windspeed_north = status.states[22];

               wind_estimate.windspeed_east = status.states[23];

               wind_estimate.covariance_north = status.covariances[22];

               wind_estimate.covariance_east = status.covariances[23];

 

               if (_wind_pub == nullptr) {

                       _wind_pub = orb_advertise(ORB_ID(wind_estimate), &wind_estimate);

 

               } else {

                       orb_publish(ORB_ID(wind_estimate), _wind_pub, &wind_estimate);

               }

 

*/

               // save the declination to the EKF2_MAG_DECL parameter when a land event is detected

 

 

               /*

               if ((_params->mag_declination_source & (1 << 1)) && !_prev_landed && vehicle_land_detected.landed) {

                       float decl_deg;

                       _ekf.copy_mag_decl_deg(&decl_deg);

                       _mag_declination_deg.set(decl_deg);

               }

               */

 

               //_prev_landed = vehicle_land_detected.landed;

 

        }

        delete ekf2::instance;
        ekf2::instance = nullptr;

}
